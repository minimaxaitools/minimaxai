
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UPSC AI Document Search & Analysis</title>

    <!-- External CSS Libraries -->
    <link href="./upsc/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="./upsc/all.min.css" rel="stylesheet">
    <link href="./upsc/prism.min.css" rel="stylesheet">

    <!-- Custom Styles -->
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #64748b;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --dark-color: #1e293b;
            --light-color: #f8fafc;
            --border-color: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-color);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            color: var(--secondary-color);
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            height: fit-content;
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .section {
            margin-bottom: 30px;
        }

        .section h3 {
            color: var(--primary-color);
            font-size: 1.3rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: var(--light-color);
        }

        .upload-zone:hover {
            border-color: var(--primary-color);
            background: rgba(37, 99, 235, 0.05);
        }

        .upload-zone.dragover {
            border-color: var(--primary-color);
            background: rgba(37, 99, 235, 0.1);
        }

        .btn {
            border-radius: 10px;
            padding: 12px 24px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress {
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            background: var(--border-color);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--success-color));
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .search-container {
            margin-bottom: 25px;
        }

        .search-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid var(--border-color);
            border-radius: 15px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .search-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .option-group {
            background: var(--light-color);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }

        .option-group h5 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .form-check {
            margin-bottom: 8px;
        }

        .form-check-input {
            margin-right: 8px;
        }

        .search-results {
            margin-top: 30px;
        }

        .result-item {
            background: var(--light-color);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .result-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .result-score {
            background: var(--primary-color);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .result-content {
            font-size: 1rem;
            line-height: 1.6;
        }

        .highlight {
            background: rgba(245, 158, 11, 0.3);
            padding: 2px 4px;
            border-radius: 4px;
            font-weight: 600;
        }

        .context-section {
            margin-top: 15px;
            padding: 15px;
            background: rgba(100, 116, 139, 0.1);
            border-radius: 10px;
            border-left: 4px solid var(--secondary-color);
        }

        .context-label {
            font-size: 0.8rem;
            color: var(--secondary-color);
            font-weight: 600;
            margin-bottom: 5px;
        }

        .context-text {
            font-size: 0.9rem;
            color: var(--secondary-color);
            font-style: italic;
        }

        .dataset-selector {
            background: var(--light-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .dataset-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .dataset-item:last-child {
            border-bottom: none;
        }

        .model-status {
            background: rgba(37, 99, 235, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .model-status.loading {
            background: rgba(245, 158, 11, 0.1);
            border-color: var(--warning-color);
        }

        .model-status.ready {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--success-color);
        }

        .export-section {
            background: var(--light-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .llm-section {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid #8b5cf6;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .llm-response {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .ad-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        .notification.success {
            background: var(--success-color);
        }

        .notification.error {
            background: var(--danger-color);
        }

        .notification.warning {
            background: var(--warning-color);
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2rem;
            }

            .search-options {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 15px;
            }

            .header {
                padding: 20px;
            }

            .sidebar, .main-panel {
                padding: 20px;
            }

            .export-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
<div class="app-container">
    <!-- Header -->
    <div class="header">
        <h1><i class="fas fa-brain"></i> AI Document Search & Analysis</h1>
        <p>Advanced AI-powered document processing and semantic search platform</p>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Model Status -->
            <div class="model-status" id="modelStatus">
                <i class="fas fa-cog fa-spin"></i>
                <div>Initializing AI Models...</div>
                <div class="progress-container">
                    <div class="progress">
                        <div class="progress-bar" id="modelProgress" style="width: 0%"></div>
                    </div>
                    <small id="modelProgressText">Preparing models...</small>
                </div>
            </div>

            <!-- Document Upload -->
            <div class="section">
                <h3><i class="fas fa-upload"></i> Upload Documents</h3>
                <div class="upload-zone" id="uploadZone">
                    <i class="fas fa-cloud-upload-alt fa-2x mb-3"></i>
                    <p>Drag & drop files here or click to select</p>
                    <p><small>Supports: PDF, TXT, DOC, DOCX</small></p>
                    <input type="file" id="fileInput" multiple accept=".pdf,.txt,.doc,.docx" style="display: none;">
                </div>
                <div class="progress-container" id="uploadProgress" style="display: none;">
                    <div class="progress">
                        <div class="progress-bar" id="uploadProgressBar"></div>
                    </div>
                    <small id="uploadProgressText">Processing documents...</small>
                </div>
            </div>

            <!-- Dataset Management -->
            <div class="section">
                <h3><i class="fas fa-database"></i> Dataset Management</h3>
                <div class="mb-3">
                    <button class="btn btn-primary" id="downloadDataset">
                        <i class="fas fa-download"></i> Download Processed Data
                    </button>
                </div>
                <!-- Add this after the dataset input -->
                <div class="mb-3">
                    <small class="text-muted">
                        <i class="fas fa-info-circle"></i>
                        For chunked datasets, select all chunk files at once.
                        For single datasets, select the JSON file.
                    </small>
                </div>

                <div class="mb-3">
                    <label class="form-label">Upload Vectorized Dataset:</label>
                    <input type="file" class="form-control" id="datasetInput" accept=".json" multiple>
                </div>
                <div class="dataset-selector" id="datasetSelector">
                    <div class="dataset-item">
                        <input type="checkbox" class="form-check-input" id="dataset_current" checked>
                        <label for="dataset_current">Current Session</label>
                    </div>
                </div>
            </div>

            <!-- Search Configuration -->
            <div class="section">
                <h3><i class="fas fa-cogs"></i> Search Configuration</h3>
                <div class="option-group">
                    <h5>Search Methods</h5>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="searchMethod" id="semantic" value="semantic">
                        <label class="form-check-label" for="semantic">Semantic Search</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="searchMethod" id="keyword" value="keyword">
                        <label class="form-check-label" for="keyword">Keyword Search</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="searchMethod" id="contextual" value="contextual">
                        <label class="form-check-label" for="contextual">Contextual Search</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="searchMethod" id="research" value="research" checked>
                        <label class="form-check-label" for="research">Research Mode</label>
                    </div>
                </div>

                <div class="option-group">
                    <h5>Search Options</h5>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="removeDuplicates" checked>
                        <label class="form-check-label" for="removeDuplicates">Remove Duplicates</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="showContext" checked>
                        <label class="form-check-label" for="showContext">Show Context</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="highlightKeywords" checked>
                        <label class="form-check-label" for="highlightKeywords">Highlight Keywords</label>
                    </div>
                </div>

                <div class="option-group">
                    <h5>Context Settings</h5>
                    <div class="mb-2">
                        <label class="form-label">Context Sentences:</label>
                        <input type="range" class="form-range" id="contextSentences" min="1" max="15" value="2">
                        <span id="contextSentencesValue">2</span>
                    </div>
                    <div class="mb-2">
                        <label class="form-label">Similarity Threshold:</label>
                        <input type="range" class="form-range" id="similarityThreshold" min="0.01" max="1" step="0.01" value="0.5">
                        <span id="similarityThresholdValue">0.5</span>
                    </div>
                </div>
            </div>

            <!-- AdSense Ad Container -->
            <div class="ad-container" id="adContainer">
                <div id="adSenseAd">
                    <!-- AdSense code will be inserted here -->
                    <div style="background: #f0f0f0; padding: 20px; border-radius: 8px; color: #666;">
                        <i class="fas fa-ad"></i><br>
                        Advertisement Space<br>
                        <small>Configure AdSense in settings</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Panel -->
        <div class="main-panel">
            <!-- Search Interface -->
            <div class="search-container">
                <div class="input-group">
                    <input type="text" class="search-input" id="searchInput" placeholder="Enter your search query...">
                    <button class="btn btn-primary" id="searchBtn">
                        <i class="fas fa-search"></i> Search
                    </button>
                </div>
            </div>

            <!-- Search Results -->
            <div class="search-results" id="searchResults"></div>

            <!-- Export Section -->
            <div class="export-section" id="exportSection" style="display: none;">
                <h5><i class="fas fa-download"></i> Export Results</h5>
                <div class="export-buttons">
                    <button class="btn btn-success" id="exportTxt">
                        <i class="fas fa-file-alt"></i> Export TXT
                    </button>
                    <button class="btn btn-success" id="exportPdf">
                        <i class="fas fa-file-pdf"></i> Export PDF
                    </button>
                    <button class="btn btn-success" id="exportJson">
                        <i class="fas fa-file-code"></i> Export JSON
                    </button>
                </div>
            </div>

            <!-- LLM Integration -->
            <div class="llm-section" id="llmSection" style="display: none;">
                <h5><i class="fas fa-robot"></i> AI Assistant (Optional)</h5>
                <div class="mb-3">
                    <select class="form-select" id="llmTask">
                        <option value="summarize">Summarize Results</option>
                        <option value="qa">Generate Q&A</option>
                        <option value="explain">Explain Concepts</option>
                        <option value="insights">Generate Insights</option>
                    </select>
                </div>
                <button class="btn btn-primary" id="generateLLM">
                    <i class="fas fa-magic"></i> Generate Response
                </button>
                <div class="llm-response" id="llmResponse" style="display: none;"></div>
            </div>
        </div>
    </div>
</div>

<!-- External JavaScript Libraries -->
<script src="./study/transformers.min.js"></script>
<script src="./study/pdf.worker.min.mjs"></script>
<script src="./study/bootstrap.bundle.min.js"></script>
<script src="./study/pdf.min.js"></script>
<script src="./study/jspdf.umd.min.js"></script>
<script src="./study/mammoth.browser.min.js"></script>
<script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<!-- Main Application Script -->
<script>
    // Configuration
    const CONFIG = {
        // Developer can set their AdSense ID here
        ADSENSE_ID: 'ca-pub-xxxxxxxxxxxxxxxxxx', // Replace with your AdSense ID

        // Model settings
        MODEL_NAME: 'Xenova/all-MiniLM-L6-v2',
        MAX_RESULTS: 10000,
        DEFAULT_SIMILARITY_THRESHOLD: 0.5,

        // UI settings
        ANIMATION_DURATION: 300,
        NOTIFICATION_DURATION: 5000
    };

    // Global variables
    let model = null;
    let tokenizer = null;
    let documents = [];
    let vectors = [];
    let datasets = new Map();
    let currentResults = [];
    let isModelLoaded = false;

    // Utility functions
    const utils = {
        // Show notification
        showNotification: (message, type = 'success') => {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, CONFIG.NOTIFICATION_DURATION);
        },

        // Cosine similarity calculation
        cosineSimilarity: (a, b) => {
            const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
            const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
            const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
            return dotProduct / (magnitudeA * magnitudeB);
        },

        // Highlight keywords in text
        highlightKeywords: (text, keywords) => {
            if (!keywords || keywords.length === 0) return text;

            let highlightedText = text;
            keywords.forEach(keyword => {
                const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                highlightedText = highlightedText.replace(regex, '<span class="highlight">$1</span>');
            });
            return highlightedText;
        },

        // Extract sentences from text
        extractSentences: (text) => {
            return text.match(/[^\.!?]+[\.!?]+/g) || [text];
        },

        // Get context sentences
        getContextSentences: (sentences, index, contextCount) => {
            const start = Math.max(0, index - contextCount);
            const end = Math.min(sentences.length, index + contextCount + 1);
            return {
                prefix: sentences.slice(start, index).join(' '),
                suffix: sentences.slice(index + 1, end).join(' ')
            };
        },

        // Remove duplicates from results
        removeDuplicates: (results) => {
            const seen = new Set();
            return results.filter(result => {
                const key = result.text.toLowerCase().trim();
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        },

        // Download file
        downloadFile: (content, filename, type) => {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        },

        // Refresh ads
        refreshAds: () => {
            if (window.adsbygoogle && CONFIG.ADSENSE_ID !== 'ca-pub-xxxxxxxxxxxxxxxxxx') {
                // Refresh AdSense ads
                try {
                    (window.adsbygoogle = window.adsbygoogle || []).push({});
                } catch (e) {
                    console.log('AdSense refresh failed:', e);
                }
            }
        }
    };

    // ML Engine
    const mlEngine = {
        // Initialize model
        init: async () => {
            try {
                const modelStatus = document.getElementById('modelStatus');
                const modelProgress = document.getElementById('modelProgress');
                const modelProgressText = document.getElementById('modelProgressText');

                modelStatus.className = 'model-status loading';
                modelProgressText.textContent = 'Loading AI models...';

                // Simulate progress
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress > 90) progress = 90;
                    modelProgress.style.width = progress + '%';
                    modelProgressText.textContent = `Loading models... ${Math.round(progress)}%`;
                }, 500);

                // Load model
                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1/dist/transformers.min.js');
                model = await pipeline('feature-extraction', CONFIG.MODEL_NAME);

                clearInterval(progressInterval);
                modelProgress.style.width = '100%';
                modelStatus.className = 'model-status ready';
                modelStatus.innerHTML = `
                        <i class="fas fa-check-circle"></i>
                        <div>AI Models Ready</div>
                        <small>Ready for document processing and search</small>
                    `;

                isModelLoaded = true;
                utils.showNotification('AI models loaded successfully!', 'success');
            } catch (error) {
                console.error('Model initialization failed:', error);
                const modelStatus = document.getElementById('modelStatus');
                modelStatus.className = 'model-status';
                modelStatus.innerHTML = `
                        <i class="fas fa-exclamation-triangle"></i>
                        <div>Model Loading Failed</div>
                        <small>Please refresh the page to try again</small>
                    `;
                utils.showNotification('Failed to load AI models. Please refresh the page.', 'error');
            }
        },

        // Generate embeddings
        generateEmbedding: async (text) => {
            if (!model) {
                throw new Error('Model not loaded');
            }

            const result = await model(text);
            return Array.from(result.data);
        },

        // Vectorize document
        vectorizeDocument: async (text, filename) => {
            const sentences = utils.extractSentences(text);
            const docVectors = [];

            for (let i = 0; i < sentences.length; i++) {
                const sentence = sentences[i].trim();
                if (sentence.length > 10) { // Skip very short sentences
                    const embedding = await mlEngine.generateEmbedding(sentence);
                    docVectors.push({
                        text: sentence,
                        vector: embedding,
                        filename: filename,
                        index: i
                    });
                }
            }

            return docVectors;
        }
    };

    // Document processor
    const documentProcessor = {
        // Process uploaded files
        processFiles: async (files) => {
            const uploadProgress = document.getElementById('uploadProgress');
            const uploadProgressBar = document.getElementById('uploadProgressBar');
            const uploadProgressText = document.getElementById('uploadProgressText');

            uploadProgress.style.display = 'block';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const progress = ((i + 1) / files.length) * 100;

                uploadProgressBar.style.width = progress + '%';
                uploadProgressText.textContent = `Processing ${file.name}... (${i + 1}/${files.length})`;

                try {
                    const text = await documentProcessor.extractText(file);
                    const docVectors = await mlEngine.vectorizeDocument(text, file.name);

                    // Add to current session
                    documents.push({
                        filename: file.name,
                        text: text,
                        vectors: docVectors
                    });

                    vectors.push(...docVectors);

                    utils.showNotification(`Processed ${file.name}`, 'success');
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                    utils.showNotification(`Failed to process ${file.name}`, 'error');
                }
            }

            uploadProgress.style.display = 'none';
            documentProcessor.updateDatasetSelector();
            utils.refreshAds();
        },

        // Extract text from file
        extractText: async (file) => {
            const fileType = file.type;
            const fileName = file.name.toLowerCase();

            if (fileType === 'text/plain' || fileName.endsWith('.txt')) {
                return await file.text();
            } else if (fileType === 'application/pdf' || fileName.endsWith('.pdf')) {
                return await documentProcessor.extractFromPDF(file);
            } else if (fileName.endsWith('.docx')) {
                return await documentProcessor.extractFromDocx(file);
            } else {
                throw new Error('Unsupported file type');
            }
        },

        // Extract text from PDF
        extractFromPDF: async (file) => {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            let text = '';

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                text += pageText + '\n';
            }

            return text;
        },

        // Extract text from DOCX
        extractFromDocx: async (file) => {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value;
        },

        // Update dataset selector
        updateDatasetSelector: () => {
            const selector = document.getElementById('datasetSelector');
            const currentDataset = selector.querySelector('#dataset_current');

            if (documents.length > 0) {
                currentDataset.parentElement.innerHTML = `
                        <input type="checkbox" class="form-check-input" id="dataset_current" checked>
                        <label for="dataset_current">Current Session (${documents.length} documents)</label>
                    `;
            }
        }
    };

    // Search engine
    const searchEngine = {

        // Add this method to searchEngine object
        addContextFromAllDatasets: (results, allDocuments, contextSentences) => {
            return results.map(result => {
                // Find document in all available datasets
                const doc = allDocuments.find(d => d.filename === result.filename);
                if (doc) {
                    const sentences = utils.extractSentences(doc.text);
                    const sentenceIndex = sentences.findIndex(s => s.includes(result.text));

                    if (sentenceIndex !== -1) {
                        const context = utils.getContextSentences(sentences, sentenceIndex, contextSentences);
                        return {
                            ...result,
                            context: context
                        };
                    }
                }
                return result;
            });
        },
        // Perform search
        // Replace the search method in searchEngine object
        search: async (query, options = {}) => {
            if (!isModelLoaded) {
                utils.showNotification('AI models are still loading. Please wait.', 'warning');
                return [];
            }

            if (!query.trim()) {
                utils.showNotification('Please enter a search query', 'warning');
                return [];
            }

            const searchMethod = options.method || 'semantic';
            const threshold = options.threshold || CONFIG.DEFAULT_SIMILARITY_THRESHOLD;
            const selectedDatasets = options.datasets || ['current'];

            let searchVectors = [];
            let searchDocuments = [];

            selectedDatasets.forEach(datasetId => {
                if (datasetId === 'current') {
                    searchVectors.push(...vectors);
                    searchDocuments.push(...documents);
                } else {
                    // Fix: Handle both old and new dataset ID formats
                    const actualDatasetId = datasetId.startsWith('dataset_') ? datasetId : `dataset_${datasetId}`;

                    if (datasets.has(actualDatasetId)) {
                        searchVectors.push(...datasets.get(actualDatasetId));
                        const datasetDocs = datasets.get(`${actualDatasetId}_docs`) || [];
                        searchDocuments.push(...datasetDocs);
                    }
                }
            });

            if (searchVectors.length === 0) {
                utils.showNotification('No documents available for search. Please upload documents or select a dataset.', 'warning');
                return [];
            }

            let results = [];

            switch (searchMethod) {
                case 'semantic':
                    results = await searchEngine.semanticSearch(query, searchVectors, threshold);
                    break;
                case 'keyword':
                    results = searchEngine.keywordSearch(query, searchVectors, threshold);
                    break;
                case 'contextual':
                    results = await searchEngine.contextualSearch(query, searchVectors, threshold);
                    break;
                case 'research':
                    results = await searchEngine.researchSearch(query, searchVectors, threshold);
                    break;
            }

            // Remove duplicates if option is enabled
            if (options.removeDuplicates) {
                results = utils.removeDuplicates(results);
            }

            // Add context if option is enabled
            if (options.showContext) {
                results = searchEngine.addContextFromAllDatasets(results, searchDocuments, options.contextSentences || 2);
            }

            return results.slice(0, CONFIG.MAX_RESULTS);
        },



        // Semantic search
        semanticSearch: async (query, searchVectors, threshold) => {
            const queryEmbedding = await mlEngine.generateEmbedding(query);
            const results = [];

            for (const vector of searchVectors) {
                const similarity = utils.cosineSimilarity(queryEmbedding, vector.vector);
                if (similarity >= threshold) {
                    results.push({
                        ...vector,
                        similarity: similarity,
                        type: 'semantic'
                    });
                }
            }

            return results.sort((a, b) => b.similarity - a.similarity);
        },

        // Keyword search
        keywordSearch: (query, searchVectors, threshold) => {
            const keywords = query.toLowerCase().split(/\s+/);
            const results = [];

            for (const vector of searchVectors) {
                const text = vector.text.toLowerCase();
                let matches = 0;

                keywords.forEach(keyword => {
                    if (text.includes(keyword)) {
                        matches++;
                    }
                });

                const similarity = matches / keywords.length;
                if (similarity >= threshold) {
                    results.push({
                        ...vector,
                        similarity: similarity,
                        type: 'keyword',
                        keywords: keywords
                    });
                }
            }

            return results.sort((a, b) => b.similarity - a.similarity);
        },

        // Contextual search
        contextualSearch: async (query, searchVectors, threshold) => {
            // Enhanced semantic search with context awareness
            const queryEmbedding = await mlEngine.generateEmbedding(query);
            const results = [];

            for (const vector of searchVectors) {
                const similarity = utils.cosineSimilarity(queryEmbedding, vector.vector);

                // Boost score based on context
                let contextBoost = 1.0;
                if (vector.filename && query.toLowerCase().includes(vector.filename.toLowerCase().replace(/\.[^/.]+$/, ""))) {
                    contextBoost = 1.2;
                }

                const adjustedSimilarity = similarity * contextBoost;

                if (adjustedSimilarity >= threshold) {
                    results.push({
                        ...vector,
                        similarity: adjustedSimilarity,
                        type: 'contextual'
                    });
                }
            }

            return results.sort((a, b) => b.similarity - a.similarity);
        },

        // Research search
        researchSearch: async (query, searchVectors, threshold) => {
            // Multi-faceted search for research purposes
            const semanticResults = await searchEngine.semanticSearch(query, searchVectors, threshold * 0.8);
            const keywordResults = searchEngine.keywordSearch(query, searchVectors, threshold * 0.6);

            // Combine and deduplicate
            const combined = [...semanticResults, ...keywordResults];
            const uniqueResults = utils.removeDuplicates(combined);

            return uniqueResults.map(result => ({
                ...result,
                type: 'research'
            })).sort((a, b) => b.similarity - a.similarity);
        },

        // Add context to results
        addContext: (results, contextSentences) => {
            return results.map(result => {
                const doc = documents.find(d => d.filename === result.filename);
                if (doc) {
                    const sentences = utils.extractSentences(doc.text);
                    const sentenceIndex = sentences.findIndex(s => s.includes(result.text));

                    if (sentenceIndex !== -1) {
                        const context = utils.getContextSentences(sentences, sentenceIndex, contextSentences);
                        return {
                            ...result,
                            context: context
                        };
                    }
                }
                return result;
            });
        }




    };

    // Export manager
    const exportManager = {
        // Export to TXT
        exportToTxt: (results) => {
            let content = `AI Document Search Results\n`;
            content += `Generated on: ${new Date().toLocaleString()}\n`;
            content += `Total Results: ${results.length}\n\n`;
            content += '='.repeat(50) + '\n\n';

            results.forEach((result, index) => {
                content += `Result ${index + 1}:\n`;
                content += `File: ${result.filename}\n`;
                content += `Similarity: ${(result.similarity * 100).toFixed(1)}%\n`;
                content += `Type: ${result.type}\n`;
                content += `Content: ${result.text}\n`;

                if (result.context) {
                    content += `\nContext:\n`;
                    if (result.context.prefix) {
                        content += `Before: ${result.context.prefix}\n`;
                    }
                    if (result.context.suffix) {
                        content += `After: ${result.context.suffix}\n`;
                    }
                }

                content += '\n' + '-'.repeat(30) + '\n\n';
            });

            utils.downloadFile(content, 'search_results.txt', 'text/plain');
            utils.refreshAds();
        },

        // Export to PDF
        exportToPdf: (results) => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');

            // Professional Design System
            const theme = {
                colors: {
                    primary: '#1E40AF',      // Professional blue
                    secondary: '#3B82F6',    // Lighter blue
                    accent: '#10B981',       // Success green
                    warning: '#F59E0B',      // Warning amber
                    error: '#EF4444',        // Error red
                    neutral: {
                        900: '#111827',        // Almost black
                        800: '#1F2937',        // Dark gray
                        700: '#374151',        // Medium gray
                        600: '#4B5563',        // Light gray
                        500: '#6B7280',        // Lighter gray
                        400: '#9CA3AF',        // Very light gray
                        300: '#D1D5DB',        // Border gray
                        200: '#E5E7EB',        // Background gray
                        100: '#F3F4F6',        // Light background
                        50: '#F9FAFB'          // Lightest background
                    },
                    white: '#FFFFFF',
                    background: '#FAFBFC'
                },
                fonts: {
                    title: 24,
                    heading: 18,
                    subheading: 14,
                    body: 11,
                    small: 9,
                    caption: 8
                },
                spacing: {
                    page: 20,
                    section: 15,
                    element: 8,
                    tight: 4,
                    line: 5
                },
                layout: {
                    maxWidth: 170,
                    contentWidth: 150,
                    sidebarWidth: 40
                }
            };

            // State Management
            let currentY = theme.spacing.page;
            let pageNumber = 1;
            const pageHeight = doc.internal.pageSize.height;
            const pageWidth = doc.internal.pageSize.width;

            // Enhanced Utility Functions
            const utils = {
                // Clean and normalize text for PDF compatibility
                cleanText: (text) => {
                    if (!text) return '';

                    return text
                        .toString()
                        // Remove problematic characters
                        .replace(/[^\x00-\x7F]/g, '')
                        // Normalize common accented characters
                        .replace(/[àáâãäå]/gi, 'a')
                        .replace(/[èéêë]/gi, 'e')
                        .replace(/[ìíîï]/gi, 'i')
                        .replace(/[òóôõö]/gi, 'o')
                        .replace(/[ùúûü]/gi, 'u')
                        .replace(/[ñ]/gi, 'n')
                        .replace(/[ç]/gi, 'c')
                        .replace(/[ß]/g, 'ss')
                        // Clean up whitespace
                        .replace(/\s+/g, ' ')
                        .replace(/\n+/g, ' ')
                        .replace(/\t+/g, ' ')
                        .trim();
                },

                // Convert hex color to RGB array
                hexToRgb: (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? [
                        parseInt(result[1], 16),
                        parseInt(result[2], 16),
                        parseInt(result[3], 16)
                    ] : [0, 0, 0];
                },

                // Check if new page is needed
                checkNewPage: (heightNeeded) => {
                    if (currentY + heightNeeded > pageHeight - theme.spacing.page) {
                        doc.addPage();
                        currentY = theme.spacing.page;
                        pageNumber++;
                        utils.addPageHeader();
                        return true;
                    }
                    return false;
                },

                // Add professional page header
                addPageHeader: () => {
                    if (pageNumber === 1) return;

                    // Header background
                    doc.setFillColor(...utils.hexToRgb(theme.colors.neutral[50]));
                    doc.rect(0, 0, pageWidth, 15, 'F');

                    // Header content
                    doc.setFontSize(theme.fonts.caption);
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[600]));
                    doc.text('AI Document Search Results', theme.spacing.page, 10);
                    doc.text(`Page ${pageNumber}`, pageWidth - 30, 10);

                    // Header line
                    doc.setDrawColor(...utils.hexToRgb(theme.colors.neutral[300]));
                    doc.setLineWidth(0.5);
                    doc.line(theme.spacing.page, 12, pageWidth - theme.spacing.page, 12);

                    currentY = 25;
                },

                // Create styled card container
                createCard: (x, y, width, height, options = {}) => {
                    const {
                        fillColor = theme.colors.white,
                        borderColor = theme.colors.neutral[300],
                        shadow = true,
                        borderRadius = false
                    } = options;

                    // Drop shadow effect
                    if (shadow) {
                        doc.setFillColor(0, 0, 0, 0.1);
                        doc.rect(x + 1, y + 1, width, height, 'F');
                    }

                    // Main card
                    doc.setFillColor(...utils.hexToRgb(fillColor));
                    doc.rect(x, y, width, height, 'F');

                    // Border
                    if (borderColor) {
                        doc.setDrawColor(...utils.hexToRgb(borderColor));
                        doc.setLineWidth(0.5);
                        doc.rect(x, y, width, height, 'S');
                    }

                    return { x, y, width, height };
                },

                // Add styled text with automatic wrapping
                addText: (text, x, y, options = {}) => {
                    const {
                        fontSize = theme.fonts.body,
                        color = theme.colors.neutral[900],
                        maxWidth = theme.layout.contentWidth,
                        lineHeight = theme.spacing.line,
                        align = 'left',
                        bold = false,
                        italic = false,
                        render = true // <- NEW FLAG
                    } = options;

                    const cleanedText = utils.cleanText(text);
                    if (!cleanedText) return 0;

                    // Set font properties
                    doc.setFontSize(fontSize);
                    doc.setTextColor(...utils.hexToRgb(color));

                    let fontStyle = 'normal';
                    if (bold && italic) fontStyle = 'bolditalic';
                    else if (bold) fontStyle = 'bold';
                    else if (italic) fontStyle = 'italic';
                    doc.setFont(undefined, fontStyle);

                    // Split text to fit width
                    const lines = doc.splitTextToSize(cleanedText, maxWidth);
                    const totalHeight = lines.length * lineHeight;

                    // Only render if render flag is true
                    if (render) {
                        // Check if we need a new page
                        utils.checkNewPage(totalHeight);

                        // Add text with alignment
                        if (align === 'center') {
                            doc.text(lines, x + maxWidth / 2, y, { align: 'center' });
                        } else if (align === 'right') {
                            doc.text(lines, x + maxWidth, y, { align: 'right' });
                        } else {
                            doc.text(lines, x, y);
                        }
                    }

                    // Reset font
                    doc.setFont(undefined, 'normal');

                    return totalHeight;
                },


                // Create progress bar for similarity scores
                createProgressBar: (percentage, x, y, width = 40, height = 4) => {
                    // Background
                    doc.setFillColor(...utils.hexToRgb(theme.colors.neutral[200]));
                    doc.rect(x, y, width, height, 'F');

                    // Progress fill
                    const progressWidth = Math.max(0, Math.min(100, percentage)) / 100 * width;
                    let progressColor = theme.colors.error;

                    if (percentage >= 80) progressColor = theme.colors.accent;
                    else if (percentage >= 60) progressColor = theme.colors.secondary;
                    else if (percentage >= 40) progressColor = theme.colors.warning;

                    doc.setFillColor(...utils.hexToRgb(progressColor));
                    doc.rect(x, y, progressWidth, height, 'F');

                    // Border
                    doc.setDrawColor(...utils.hexToRgb(theme.colors.neutral[400]));
                    doc.setLineWidth(0.3);
                    doc.rect(x, y, width, height, 'S');
                },

                // Create numbered badge
                createBadge: (number, x, y, size = 8) => {
                    const radius = size / 2;

                    // Badge background
                    doc.setFillColor(...utils.hexToRgb(theme.colors.primary));
                    doc.circle(x + radius, y + radius, radius, 'F');

                    // Badge number
                    doc.setFontSize(theme.fonts.small);
                    doc.setTextColor(255, 255, 255);
                    doc.setFont(undefined, 'bold');
                    doc.text(number.toString(), x + radius, y + radius + 1, { align: 'center' });
                    doc.setFont(undefined, 'normal');

                    return size;
                },

                // Create section divider
                createDivider: (x, y, width, style = 'solid') => {
                    doc.setDrawColor(...utils.hexToRgb(theme.colors.neutral[300]));

                    if (style === 'dashed') {
                        doc.setLineDashPattern([2, 2], 0);
                    } else if (style === 'dotted') {
                        doc.setLineDashPattern([1, 1], 0);
                    }

                    doc.setLineWidth(0.5);
                    doc.line(x, y, x + width, y);
                    doc.setLineDashPattern([], 0); // Reset dash pattern
                }
            };

            // Main PDF Generation Functions
            const generators = {
                // Create document header
                createHeader: () => {
                    // Main header background
                    utils.createCard(0, 0, pageWidth, 45, {
                        fillColor: theme.colors.primary,
                        borderColor: null,
                        shadow: false
                    });

                    // Title
                    doc.setFontSize(theme.fonts.title);
                    doc.setTextColor(255, 255, 255);
                    doc.setFont(undefined, 'bold');
                    doc.text('AI Document Search Results', theme.spacing.page, 20);
                    doc.setFont(undefined, 'normal');

                    // Subtitle
                    doc.setFontSize(theme.fonts.small);
                    doc.setTextColor(255, 255, 255);
                    doc.text('Comprehensive Search Analysis Report', theme.spacing.page, 30);

                    // Generated timestamp
                    doc.setFontSize(theme.fonts.caption);
                    doc.text(`Generated: ${new Date().toLocaleString()}`, theme.spacing.page, 38);

                    currentY = 55;
                },

                // Create summary statistics
                createSummary: () => {
                    if (results.length === 0) return;

                    // Calculate statistics
                    const totalResults = results.length;
                    const avgSimilarity = results.reduce((sum, r) => sum + (r.similarity || 0), 0) / totalResults;
                    const maxSimilarity = Math.max(...results.map(r => r.similarity || 0));
                    const minSimilarity = Math.min(...results.map(r => r.similarity || 0));

                    // Summary header
                    utils.addText('Executive Summary', theme.spacing.page, currentY, {
                        fontSize: theme.fonts.heading,
                        color: theme.colors.neutral[900],
                        bold: true
                    });
                    currentY += 15;

                    // Summary cards
                    const cardWidth = 45;
                    const cardHeight = 25;
                    const cardSpacing = 5;
                    const cards = [
                        { label: 'Total Results', value: totalResults, color: theme.colors.primary },
                        { label: 'Avg Relevance', value: `${(avgSimilarity * 100).toFixed(1)}%`, color: theme.colors.secondary },
                        { label: 'Best Match', value: `${(maxSimilarity * 100).toFixed(1)}%`, color: theme.colors.accent },
                        { label: 'Range', value: `${((maxSimilarity - minSimilarity) * 100).toFixed(1)}%`, color: theme.colors.warning }
                    ];

                    cards.forEach((card, index) => {
                        const x = theme.spacing.page + index * (cardWidth + cardSpacing);

                        // Card background
                        utils.createCard(x, currentY, cardWidth, cardHeight, {
                            fillColor: theme.colors.neutral[50],
                            borderColor: theme.colors.neutral[300]
                        });

                        // Card content
                        doc.setFontSize(theme.fonts.caption);
                        doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[600]));
                        doc.text(card.label, x + 3, currentY + 8);

                        doc.setFontSize(theme.fonts.subheading);
                        doc.setTextColor(...utils.hexToRgb(card.color));
                        doc.setFont(undefined, 'bold');
                        doc.text(String(card.value), x + 3, currentY + 18);
                        doc.setFont(undefined, 'normal');
                    });

                    currentY += cardHeight + theme.spacing.section;
                },

                // Create individual result
                createResult: (result, index) => {
                    const startY = currentY;

                    // Estimate required height
                    const estimatedHeight = 80 +
                        (result.context?.prefix ? 20 : 0) +
                        (result.context?.suffix ? 20 : 0) +
                        (result.text ? Math.ceil(result.text.length / 100) * 5 : 0);

                    utils.checkNewPage(estimatedHeight);

                    // Result container
                    utils.createCard(theme.spacing.page, currentY, theme.layout.maxWidth, estimatedHeight - 10, {
                        fillColor: theme.colors.white,
                        borderColor: theme.colors.neutral[300],
                        shadow: true
                    });

                    // Result header
                    const headerY = currentY + theme.spacing.element;

                    // Result number badge
                    utils.createBadge(index + 1, theme.spacing.page + 5, headerY, 12);

                    // Result title
                    doc.setFontSize(theme.fonts.subheading);
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[900]));
                    doc.setFont(undefined, 'bold');
                    doc.text(`Search Result ${index + 1}`, theme.spacing.page + 22, headerY + 8);
                    doc.setFont(undefined, 'normal');

                    // Metadata row
                    const metaY = headerY + 15;
                    utils.createCard(theme.spacing.page + 5, metaY, theme.layout.maxWidth - 10, 12, {
                        fillColor: theme.colors.neutral[50],
                        borderColor: theme.colors.neutral[200]
                    });

                    // Source
                    doc.setFontSize(theme.fonts.small);
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[600]));
                    doc.text('Source:', theme.spacing.page + 8, metaY + 5);
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[900]));
                    doc.text(utils.cleanText(result.filename || 'Unknown Document'), theme.spacing.page + 25, metaY + 5);

                    // Relevance with progress bar
                    const relevancePercent = (result.similarity || 0) * 100;
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[600]));
                    doc.text('Relevance:', theme.spacing.page + 8, metaY + 9);

                    utils.createProgressBar(relevancePercent, theme.spacing.page + 30, metaY + 6, 30, 3);

                    doc.setFontSize(theme.fonts.small);
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[900]));
                    doc.setFont(undefined, 'bold');
                    doc.text(`${relevancePercent.toFixed(1)}%`, theme.spacing.page + 65, metaY + 9);
                    doc.setFont(undefined, 'normal');

                    currentY = metaY + 20;

                    // Context before (if available)
                    if (result.context?.prefix) {
                        generators.createContextSection(result.context.prefix, 'Context Before', theme.colors.neutral[100]);
                    }

                    // Main content
                    generators.createMainContent(result.text || 'No content available');

                    // Context after (if available)
                    if (result.context?.suffix) {
                        generators.createContextSection(result.context.suffix, 'Context After', theme.colors.neutral[100]);
                    }

                    currentY += theme.spacing.section;
                },


                // Create context section
                createContextSection: (text, label, backgroundColor) => {
                    const sectionY = currentY;

                    // Estimate text height WITHOUT rendering
                    const estimatedTextHeight = utils.addText(text, 0, 0, {
                        fontSize: theme.fonts.small,
                        maxWidth: theme.layout.maxWidth - 20,
                        lineHeight: 4,
                        render: false // <- Prevents rendering at (0,0)
                    });

                    // Context background first
                    utils.createCard(theme.spacing.page + 5, sectionY, theme.layout.maxWidth - 10, estimatedTextHeight + 15, {
                        fillColor: backgroundColor,
                        borderColor: theme.colors.neutral[200]
                    });

                    // Context header
                    doc.setFontSize(theme.fonts.small);
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[600]));
                    doc.setFont(undefined, 'bold');
                    doc.text(label, theme.spacing.page + 8, sectionY + 6);
                    doc.setFont(undefined, 'normal');

                    currentY += 10;

                    // Context text - NOW render it properly
                    const textHeight = utils.addText(text, theme.spacing.page + 10, currentY, {
                        fontSize: theme.fonts.small,
                        color: theme.colors.neutral[700],
                        maxWidth: theme.layout.maxWidth - 20,
                        lineHeight: 4,
                        render: true // <- Renders at correct position
                    });

                    currentY += textHeight + 10;
                },



                // Create main content section
                createMainContent: (text) => {
                    const sectionY = currentY;

                    // Header card
                    utils.createCard(theme.spacing.page + 5, sectionY, theme.layout.maxWidth - 10, 8, {
                        fillColor: theme.colors.secondary,
                        borderColor: null
                    });

                    doc.setFontSize(theme.fonts.small);
                    doc.setTextColor(255, 255, 255);
                    doc.setFont(undefined, 'bold');
                    doc.text('Main Content', theme.spacing.page + 8, sectionY + 5);
                    doc.setFont(undefined, 'normal');

                    currentY += 15;

                    // Estimate text height WITHOUT rendering
                    const estimatedHeight = utils.addText(text, 0, 0, {
                        fontSize: theme.fonts.body,
                        maxWidth: theme.layout.maxWidth - 16,
                        lineHeight: 6,
                        render: false // <- Prevents rendering at (0,0)
                    });

                    // Draw card background BEFORE text
                    utils.createCard(theme.spacing.page + 5, sectionY + 8, theme.layout.maxWidth - 10, estimatedHeight + 15, {
                        fillColor: theme.colors.white,
                        borderColor: theme.colors.primary
                    });

                    // Now draw actual content text at correct position
                    const textHeight = utils.addText(text, theme.spacing.page + 8, currentY, {
                        fontSize: theme.fonts.body,
                        color: theme.colors.neutral[900],
                        maxWidth: theme.layout.maxWidth - 16,
                        lineHeight: 6,
                        render: true // <- Renders at correct position
                    });

                    currentY += textHeight + 10;
                },



                // Create footer
                createFooter: () => {
                    const footerY = pageHeight - 20;

                    // Footer background
                    doc.setFillColor(...utils.hexToRgb(theme.colors.neutral[50]));
                    doc.rect(0, footerY - 5, pageWidth, 25, 'F');

                    // Footer content
                    doc.setFontSize(theme.fonts.caption);
                    doc.setTextColor(...utils.hexToRgb(theme.colors.neutral[600]));
                    doc.text('AI Document Search System', theme.spacing.page, footerY + 5);
                    doc.text(`${new Date().toLocaleDateString()}`, theme.spacing.page, footerY + 10);
                    doc.text(`Total Results: ${results.length}`, pageWidth - 50, footerY + 5);
                    doc.text(`Pages: ${pageNumber}`, pageWidth - 50, footerY + 10);
                }
            };

            // Generate PDF
            try {
                // Create header
                generators.createHeader();

                // Create summary
                generators.createSummary();

                // Results section header
                utils.createDivider(theme.spacing.page, currentY, theme.layout.maxWidth);
                currentY += 10;

                utils.addText('Detailed Results', theme.spacing.page, currentY, {
                    fontSize: theme.fonts.heading,
                    color: theme.colors.neutral[900],
                    bold: true
                });
                currentY += 20;

                // Process each result
                results.forEach((result, index) => {
                    generators.createResult(result, index);

                    // Add divider between results (except last)
                    if (index < results.length - 1) {
                        utils.createDivider(theme.spacing.page + 10, currentY, theme.layout.maxWidth - 20, 'dashed');
                        currentY += 15;
                    }
                });

                // Create footer
                generators.createFooter();

                // Save PDF
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = `AI_Search_Results_${timestamp}.pdf`;
                doc.save(filename);

                // Optional: Refresh ads if available
                if (typeof utils !== 'undefined' && utils.refreshAds) {
                    utils.refreshAds();
                }

                return {
                    success: true,
                    filename,
                    totalResults: results.length,
                    pages: pageNumber
                };

            } catch (error) {
                console.error('PDF Export Error:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        },


        // Export to JSON
        exportToJson: (results) => {
            const exportData = {
                metadata: {
                    generatedOn: new Date().toISOString(),
                    totalResults: results.length,
                    searchMethod: document.querySelector('input[name="searchMethod"]:checked').value
                },
                results: results.map(result => ({
                    filename: result.filename,
                    text: result.text,
                    similarity: result.similarity,
                    type: result.type,
                    context: result.context || null
                }))
            };

            const content = JSON.stringify(exportData, null, 2);
            utils.downloadFile(content, 'search_results.json', 'application/json');
            utils.refreshAds();
        }

    };

    // Dataset manager
    // Enhanced Dataset manager with chunking support
    const datasetManager = {
        CHUNK_SIZE: 1000, // Vectors per chunk
        MAX_CHUNK_SIZE: 50 * 1024 * 1024, // 50MB per chunk

        // Download processed dataset in chunks
        downloadDataset: () => {
            if (documents.length === 0) {
                utils.showNotification('No documents to download', 'warning');
                return;
            }

            try {
                const metadata = {
                    createdOn: new Date().toISOString(),
                    documentCount: documents.length,
                    vectorCount: vectors.length,
                    version: '1.0',
                    totalChunks: 0
                };

                // Calculate chunks needed
                const chunks = datasetManager.createChunks(vectors, documents);
                metadata.totalChunks = chunks.length;

                // Download metadata first
                const metadataContent = JSON.stringify(metadata, null, 2);
                utils.downloadFile(metadataContent, 'dataset_metadata.json', 'application/json');

                // Download chunks
                chunks.forEach((chunk, index) => {
                    const chunkData = {
                        chunkIndex: index,
                        totalChunks: chunks.length,
                        metadata: metadata,
                        vectors: chunk.vectors,
                        documents: chunk.documents
                    };

                    const content = JSON.stringify(chunkData, null, 2);
                    utils.downloadFile(content, `dataset_chunk_${index + 1}.json`, 'application/json');
                });

                utils.showNotification(`Dataset downloaded in ${chunks.length} chunks!`, 'success');
                utils.refreshAds();
            } catch (error) {
                console.error('Download error:', error);
                utils.showNotification('Failed to download dataset. Try reducing document size.', 'error');
            }
        },

        // Create chunks from vectors and documents
        createChunks: (vectors, documents) => {
            const chunks = [];
            let currentChunk = { vectors: [], documents: [] };
            let currentSize = 0;

            for (let i = 0; i < vectors.length; i++) {
                const vector = vectors[i];
                const vectorSize = JSON.stringify(vector).length;

                if (currentSize + vectorSize > datasetManager.MAX_CHUNK_SIZE ||
                    currentChunk.vectors.length >= datasetManager.CHUNK_SIZE) {
                    if (currentChunk.vectors.length > 0) {
                        chunks.push(currentChunk);
                        currentChunk = { vectors: [], documents: [] };
                        currentSize = 0;
                    }
                }

                currentChunk.vectors.push(vector);
                currentSize += vectorSize;

                // Add corresponding document if not already included
                const doc = documents.find(d => d.filename === vector.filename);
                if (doc && !currentChunk.documents.find(d => d.filename === doc.filename)) {
                    currentChunk.documents.push({
                        filename: doc.filename,
                        text: doc.text
                    });
                }
            }

            if (currentChunk.vectors.length > 0) {
                chunks.push(currentChunk);
            }

            return chunks;
        },

        // Upload dataset (supports both single files and chunks)
        // Replace uploadDataset method in datasetManager
        uploadDataset: async (file) => {
            try {
                const content = await file.text();
                const datasetData = JSON.parse(content);

                const format = datasetManager.validateDataset(datasetData);

                switch (format) {
                    case 'chunk':
                        await datasetManager.processChunk(datasetData, file.name);
                        break;
                    case 'complete':
                        await datasetManager.processCompleteDataset(datasetData, file.name);
                        break;
                    case 'legacy':
                        await datasetManager.processLegacyDataset(datasetData, file.name);
                        break;
                    default:
                        throw new Error('Unsupported dataset format');
                }

            } catch (error) {
                console.error('Dataset upload error:', error);
                utils.showNotification(`Failed to upload ${file.name}: ${error.message}`, 'error');
                throw error;
            }
        },

        // Add this method to datasetManager
        validateDataset: (datasetData) => {
            if (!datasetData) {
                throw new Error('Empty dataset');
            }

            // Check for chunk format
            if (datasetData.chunkIndex !== undefined) {
                if (!datasetData.vectors || !Array.isArray(datasetData.vectors)) {
                    throw new Error('Invalid chunk: vectors array missing');
                }
                return 'chunk';
            }

            // Check for complete dataset format
            if (datasetData.vectors && Array.isArray(datasetData.vectors)) {
                return 'complete';
            }

            // Check for old format compatibility
            if (Array.isArray(datasetData) && datasetData.length > 0 && datasetData[0].vector) {
                return 'legacy';
            }

            throw new Error('Unrecognized dataset format');
        },

// Add legacy dataset support
        processLegacyDataset: async (datasetData, filename) => {
            const timestamp = Date.now();
            const datasetId = `dataset_${timestamp}`;

            // Convert legacy format to new format
            const vectors = Array.isArray(datasetData) ? datasetData : [];
            datasets.set(datasetId, vectors);

            // Extract documents from vectors
            const uniqueFiles = [...new Set(vectors.map(v => v.filename))];
            const datasetDocs = uniqueFiles.map(filename => ({
                filename: filename,
                text: vectors.filter(v => v.filename === filename).map(v => v.text).join(' ')
            }));

            datasets.set(`${datasetId}_docs`, datasetDocs);

            // Add to selector
            datasetManager.addDatasetToSelector(datasetId, filename, datasetDocs.length);

            utils.showNotification(`Legacy dataset uploaded: ${filename} (${datasetDocs.length} documents)`, 'success');
        },


// Update processCompleteDataset method
        processCompleteDataset: async (datasetData, filename) => {
            const timestamp = Date.now();
            const datasetId = `dataset_${timestamp}`;

            // Validate dataset structure
            if (!datasetData.vectors || !Array.isArray(datasetData.vectors)) {
                throw new Error('Invalid dataset: vectors array not found');
            }

            // Store vectors for search
            datasets.set(datasetId, datasetData.vectors);

            // Store documents for context (handle both old and new formats)
            let datasetDocs = [];
            if (datasetData.documents && Array.isArray(datasetData.documents)) {
                datasetDocs = datasetData.documents;
            } else if (datasetData.vectors.length > 0) {
                // Extract unique documents from vectors
                const uniqueFiles = [...new Set(datasetData.vectors.map(v => v.filename))];
                datasetDocs = uniqueFiles.map(filename => ({
                    filename: filename,
                    text: datasetData.vectors.filter(v => v.filename === filename).map(v => v.text).join(' ')
                }));
            }

            datasets.set(`${datasetId}_docs`, datasetDocs);

            // Add to selector
            datasetManager.addDatasetToSelector(datasetId, filename, datasetDocs.length);

            console.log(`Dataset loaded: ${datasetId} with ${datasetData.vectors.length} vectors and ${datasetDocs.length} documents`);
            utils.showNotification(`Dataset uploaded: ${filename} (${datasetDocs.length} documents, ${datasetData.vectors.length} vectors)`, 'success');
        },

// Update processChunk method
        processChunk: async (chunkData, filename) => {
            const baseId = `dataset_${chunkData.metadata.createdOn.replace(/[^0-9]/g, '').substring(0, 13)}`;

            // Get or create dataset entry
            let existingVectors = datasets.get(baseId) || [];
            let existingDocs = datasets.get(`${baseId}_docs`) || [];

            // Add chunk data
            if (chunkData.vectors && Array.isArray(chunkData.vectors)) {
                existingVectors.push(...chunkData.vectors);
            }

            // Add documents (avoid duplicates)
            if (chunkData.documents && Array.isArray(chunkData.documents)) {
                chunkData.documents.forEach(doc => {
                    if (!existingDocs.find(d => d.filename === doc.filename)) {
                        existingDocs.push(doc);
                    }
                });
            }

            // Store updated data
            datasets.set(baseId, existingVectors);
            datasets.set(`${baseId}_docs`, existingDocs);

            // Update selector
            datasetManager.updateDatasetSelector(baseId, filename, existingDocs.length, chunkData.chunkIndex + 1, chunkData.totalChunks);

            console.log(`Chunk processed: ${baseId} now has ${existingVectors.length} vectors and ${existingDocs.length} documents`);
            utils.showNotification(`Chunk ${chunkData.chunkIndex + 1}/${chunkData.totalChunks} uploaded (${existingDocs.length} total docs)`, 'success');
        },


        // Add dataset to selector
        addDatasetToSelector: (datasetId, filename, docCount) => {
            const selector = document.getElementById('datasetSelector');
            const datasetItem = document.createElement('div');
            datasetItem.className = 'dataset-item';
            datasetItem.innerHTML = `
      <input type="checkbox" class="form-check-input" id="${datasetId}" checked>
      <label for="${datasetId}">${filename} (${docCount} docs)</label>
    `;
            selector.appendChild(datasetItem);
        },

        // Update dataset selector for chunks
        updateDatasetSelector: (datasetId, filename, docCount, currentChunk, totalChunks) => {
            const selector = document.getElementById('datasetSelector');
            let existingItem = selector.querySelector(`#${datasetId}`);

            if (existingItem) {
                existingItem.nextElementSibling.textContent = `${filename} (${docCount} docs) - ${currentChunk}/${totalChunks} chunks`;
            } else {
                datasetManager.addDatasetToSelector(datasetId, `${filename} (${currentChunk}/${totalChunks})`, docCount);
            }
        }



    };


    // UI Manager
    const uiManager = {
        // Initialize UI
        init: () => {
            uiManager.setupEventListeners();
            uiManager.setupAdSense();
            mlEngine.init();
        },

        // Setup event listeners
        setupEventListeners: () => {
            // File upload
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });
            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('dragover');
            });
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    documentProcessor.processFiles(files);
                }
            });

            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    documentProcessor.processFiles(files);
                }
            });

            // Dataset management
            document.getElementById('downloadDataset').addEventListener('click', () => {
                datasetManager.downloadDataset();
            });

            document.getElementById('datasetInput').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    datasetManager.uploadDataset(file);
                }
            });

            // Add this to uiManager.setupEventListeners after the existing dataset input listener
            // Replace the existing dataset input listener with this enhanced version
            document.getElementById('datasetInput').addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    const uploadProgress = document.getElementById('uploadProgress');
                    const uploadProgressBar = document.getElementById('uploadProgressBar');
                    const uploadProgressText = document.getElementById('uploadProgressText');

                    uploadProgress.style.display = 'block';

                    try {
                        // Process each file
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            const progress = ((i + 1) / files.length) * 100;

                            uploadProgressBar.style.width = progress + '%';
                            uploadProgressText.textContent = `Processing ${file.name}... (${i + 1}/${files.length})`;

                            await datasetManager.uploadDataset(file);
                        }

                        utils.showNotification(`Successfully uploaded ${files.length} dataset file(s)`, 'success');
                    } catch (error) {
                        console.error('Dataset upload error:', error);
                        utils.showNotification('Failed to upload some dataset files', 'error');
                    } finally {
                        uploadProgress.style.display = 'none';
                        e.target.value = ''; // Reset input
                    }
                }
            });



            // Search
            const searchBtn = document.getElementById('searchBtn');
            const searchInput = document.getElementById('searchInput');

            searchBtn.addEventListener('click', () => {
                uiManager.performSearch();
            });

            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    uiManager.performSearch();
                }
            });

            // Range inputs
            const contextSentences = document.getElementById('contextSentences');
            const contextSentencesValue = document.getElementById('contextSentencesValue');
            contextSentences.addEventListener('input', (e) => {
                contextSentencesValue.textContent = e.target.value;
            });

            const similarityThreshold = document.getElementById('similarityThreshold');
            const similarityThresholdValue = document.getElementById('similarityThresholdValue');
            similarityThreshold.addEventListener('input', (e) => {
                similarityThresholdValue.textContent = e.target.value;
            });

            // Export buttons
            document.getElementById('exportTxt').addEventListener('click', () => {
                exportManager.exportToTxt(currentResults);
            });
            document.getElementById('exportPdf').addEventListener('click', () => {
                exportManager.exportToPdf(currentResults);
            });
            document.getElementById('exportJson').addEventListener('click', () => {
                exportManager.exportToJson(currentResults);
            });

            // LLM generation
            document.getElementById('generateLLM').addEventListener('click', () => {
                uiManager.generateLLMResponse();
            });
        },

        // Setup AdSense
        setupAdSense: () => {
            if (CONFIG.ADSENSE_ID && CONFIG.ADSENSE_ID !== 'ca-pub-xxxxxxxxxxxxxxxxxx') {
                const adScript = document.createElement('script');
                adScript.async = true;
                adScript.src = `https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${CONFIG.ADSENSE_ID}`;
                adScript.crossOrigin = 'anonymous';
                document.head.appendChild(adScript);

                // Initialize first ad
                setTimeout(() => {
                    utils.refreshAds();
                }, 1000);
            }
        },

        // Perform search
        performSearch: async () => {
            const query = document.getElementById('searchInput').value;
            const searchMethod = document.querySelector('input[name="searchMethod"]:checked').value;
            const removeDuplicates = document.getElementById('removeDuplicates').checked;
            const showContext = document.getElementById('showContext').checked;
            const highlightKeywords = document.getElementById('highlightKeywords').checked;
            const contextSentences = parseInt(document.getElementById('contextSentences').value);
            const threshold = parseFloat(document.getElementById('similarityThreshold').value);

            // Get selected datasets
            const selectedDatasets = [];
            document.querySelectorAll('#datasetSelector input[type="checkbox"]:checked').forEach(checkbox => {
                selectedDatasets.push(checkbox.id.replace('dataset_', ''));
            });

            const searchBtn = document.getElementById('searchBtn');
            const originalText = searchBtn.innerHTML;
            searchBtn.innerHTML = '<span class="spinner"></span> Searching...';
            searchBtn.disabled = true;

            try {
                const results = await searchEngine.search(query, {
                    method: searchMethod,
                    threshold: threshold,
                    removeDuplicates: removeDuplicates,
                    showContext: showContext,
                    contextSentences: contextSentences,
                    datasets: selectedDatasets
                });

                currentResults = results;
                uiManager.displayResults(results, query, highlightKeywords);

                if (results.length > 0) {
                    document.getElementById('exportSection').style.display = 'block';
                    document.getElementById('llmSection').style.display = 'block';
                }

                utils.refreshAds();
            } catch (error) {
                console.error('Search error:', error);
                utils.showNotification('Search failed. Please try again.', 'error');
            } finally {
                searchBtn.innerHTML = originalText;
                searchBtn.disabled = false;
            }
        },

        // Display search results
        displayResults: (results, query, highlightKeywords) => {
            const resultsContainer = document.getElementById('searchResults');

            if (results.length === 0) {
                resultsContainer.innerHTML = `
                        <div class="result-item">
                            <div class="text-center">
                                <i class="fas fa-search fa-3x mb-3 text-muted"></i>
                                <h5>No results found</h5>
                                <p>Try adjusting your search query or lowering the similarity threshold.</p>
                            </div>
                        </div>
                    `;
                return;
            }

            const keywords = query.toLowerCase().split(/\s+/);

            resultsContainer.innerHTML = results.map((result, index) => {
                let displayText = result.text;
                if (highlightKeywords) {
                    displayText = utils.highlightKeywords(displayText, keywords);
                }

                let contextHtml = '';
                if (result.context) {
                    contextHtml = `
                            <div class="context-section">
                                ${result.context.prefix ? `
                                    <div class="context-label">Before:</div>
                                    <div class="context-text">${result.context.prefix}</div>
                                ` : ''}
                                ${result.context.suffix ? `
                                    <div class="context-label">After:</div>
                                    <div class="context-text">${result.context.suffix}</div>
                                ` : ''}
                            </div>
                        `;
                }

                return `
                        <div class="result-item">
                            <div class="result-header">
                                <div>
                                    <strong>${result.filename}</strong>
                                    <span class="badge bg-secondary ms-2">${result.type}</span>
                                </div>
                                <div class="result-score">${(result.similarity * 100).toFixed(1)}%</div>
                            </div>
                            <div class="result-content">${displayText}</div>
                            ${contextHtml}
                        </div>
                    `;
            }).join('');
        },

        // Generate LLM response
        generateLLMResponse: async () => {
            if (currentResults.length === 0) {
                utils.showNotification('No search results to process', 'warning');
                return;
            }

            const task = document.getElementById('llmTask').value;
            const generateBtn = document.getElementById('generateLLM');
            const responseDiv = document.getElementById('llmResponse');

            const originalText = generateBtn.innerHTML;
            generateBtn.innerHTML = '<span class="spinner"></span> Generating...';
            generateBtn.disabled = true;

            try {
                // Simulate LLM processing (replace with actual LLM API call)
                const response = await uiManager.simulateLLMResponse(currentResults, task);

                responseDiv.innerHTML = response;
                responseDiv.style.display = 'block';

                utils.refreshAds();
            } catch (error) {
                console.error('LLM generation error:', error);
                utils.showNotification('Failed to generate response. Please try again.', 'error');
            } finally {
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
            }
        },

        // Simulate LLM response (replace with actual LLM integration)
        simulateLLMResponse: async (results, task) => {
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 2000));

            const topResults = results.slice(0, 3);
            const context = topResults.map(r => r.text).join('\n\n');

            switch (task) {
                case 'summarize':
                    return `
                            <h6><i class="fas fa-file-alt"></i> Summary</h6>
                            <p>Based on the search results, here's a summary of the key findings:</p>
                            <ul>
                                ${topResults.map(r => `<li>${r.text.substring(0, 100)}...</li>`).join('')}
                            </ul>
                            <p><em>This summary is based on the top ${topResults.length} most relevant results from your search.</em></p>
                        `;

                case 'qa':
                    return `
                            <h6><i class="fas fa-question-circle"></i> Generated Questions & Answers</h6>
                            <div class="mb-3">
                                <strong>Q: What are the main topics covered in these results?</strong>
                                <p>A: The results cover various aspects related to your search query, with focus on the most relevant information found in your documents.</p>
                            </div>
                            <div class="mb-3">
                                <strong>Q: How reliable are these findings?</strong>
                                <p>A: The results are ranked by similarity score, with the highest scoring results being most relevant to your query.</p>
                            </div>
                        `;

                case 'explain':
                    return `
                            <h6><i class="fas fa-lightbulb"></i> Explanation</h6>
                            <p>The search results provide insights into your query by analyzing the content semantically. Here's what the results tell us:</p>
                            <ol>
                                <li><strong>Relevance:</strong> Results are ranked by similarity to your search query</li>
                                <li><strong>Context:</strong> Each result comes from specific documents in your collection</li>
                                <li><strong>Connections:</strong> The AI identifies semantic relationships between concepts</li>
                            </ol>
                            <p><em>This explanation is generated based on the search methodology and result patterns.</em></p>
                        `;

                case 'insights':
                    return `
                            <h6><i class="fas fa-chart-line"></i> Key Insights</h6>
                            <div class="row">
                                <div class="col-md-6">
                                    <strong>Document Coverage:</strong>
                                    <ul>
                                        ${[...new Set(topResults.map(r => r.filename))].map(f => `<li>${f}</li>`).join('')}
                                    </ul>
                                </div>
                                <div class="col-md-6">
                                    <strong>Similarity Scores:</strong>
                                    <ul>
                                        ${topResults.map(r => `<li>${(r.similarity * 100).toFixed(1)}% relevance</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                            <p><strong>Research Tip:</strong> Consider exploring the context around these results for deeper understanding.</p>
                        `;

                default:
                    return `<p>Task completed successfully. Results processed and analyzed.</p>`;
            }
        }
    };

    // Initialize application
    document.addEventListener('DOMContentLoaded', () => {
        uiManager.init();
    });
</script>
</body>
</html><script>
    (function() {
        var ws = new WebSocket('ws://' + window.location.host +
            '/jb-server-page?reloadMode=RELOAD_ON_SAVE&'+
            'referrer=' + encodeURIComponent(window.location.pathname));
        ws.onmessage = function (msg) {
            if (msg.data === 'reload') {
                window.location.reload();
            }
            if (msg.data.startsWith('update-css ')) {
                var messageId = msg.data.substring(11);
                var links = document.getElementsByTagName('link');
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    if (link.rel !== 'stylesheet') continue;
                    var clonedLink = link.cloneNode(true);
                    var newHref = link.href.replace(/(&|\?)jbUpdateLinksId=\d+/, "$1jbUpdateLinksId=" + messageId);
                    if (newHref !== link.href) {
                        clonedLink.href = newHref;
                    }
                    else {
                        var indexOfQuest = newHref.indexOf('?');
                        if (indexOfQuest >= 0) {
                            // to support ?foo#hash
                            clonedLink.href = newHref.substring(0, indexOfQuest + 1) + 'jbUpdateLinksId=' + messageId + '&' +
                                newHref.substring(indexOfQuest + 1);
                        }
                        else {
                            clonedLink.href += '?' + 'jbUpdateLinksId=' + messageId;
                        }
                    }
                    link.replaceWith(clonedLink);
                }
            }
        };
    })();
</script>
